<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CSSMin.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">j2html</a> &gt; <a href="index.source.html" class="el_package">j2html.utils</a> &gt; <span class="el_source">CSSMin.java</span></div><h1>CSSMin.java</h1><pre class="source lang-java linenums">/*
 * * CSSMin Copyright License Agreement (BSD License)
 * &lt;p&gt;
 * Copyright (c) 2011-2014, Barry van Oudtshoorn
 * All rights reserved.
 * &lt;p&gt;
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * &lt;p&gt;
 * - Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the
 * following disclaimer.
 * &lt;p&gt;
 * - Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 * &lt;p&gt;
 * - Neither the name of Barryvan nor the names of its
 * contributors may be used to endorse or promote products
 * derived from this software without specific prior
 * written permission.
 * &lt;p&gt;
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * &lt;p&gt;
 * CSSMin takes in well-formed, human-readable CSS and reduces its size substantially.
 * It removes unnecessary whitespace and comments, and orders the contents of CSS
 * selectors alphabetically to enhance GZIP compression.
 * &lt;p&gt;
 * Originally by Barry van Oudtshoorn, with bug reports, fixes, and contributions by
 * &lt;ul&gt;
 * &lt;li&gt;Kevin de Groote&lt;/li&gt;
 * &lt;li&gt;Pedro Pinheiro&lt;/li&gt;
 * &lt;li&gt;Asier Lostalé&lt;/li&gt;
 * &lt;li&gt;David Åse&lt;/li&gt;
 * &lt;/ul&gt;
 * Some code is based on the YUI CssCompressor code, by Julien Lecomte.
 *
 * @author Barry van Oudtshoorn
 * Repo: https://github.com/barryvan/CSSMin
 */

package j2html.utils;

import java.io.BufferedReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Vector;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

public class CSSMin {

<span class="fc" id="L68">    private static final Logger LOG = Logger.getLogger(CSSMin.class.getName());</span>
<span class="fc" id="L69">    static boolean debugLogging = false;</span>

    private CSSMin() {
    }

    /**
     * Minify supplied CSS.
     *
     * @param input the CSS
     * @return the compressed version
     */
    public static String compressCss(String input) {
        try {
            int k,
                j, // Number of open braces
                n; // Current position in stream
            char curr;

<span class="fc" id="L87">            BufferedReader br = new BufferedReader(new StringReader(input));</span>
<span class="fc" id="L88">            StringBuilder sb = new StringBuilder();</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">            if (debugLogging) {</span>
<span class="nc" id="L91">                LOG.info(&quot;Reading file into StringBuffer...&quot;);</span>
            }
            String s;
<span class="fc bfc" id="L94" title="All 2 branches covered.">            while ((s = br.readLine()) != null) {</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">                if (s.trim().equals(&quot;&quot;)) {</span>
<span class="nc" id="L96">                    continue;</span>
                }
<span class="fc" id="L98">                sb.append(s);</span>
            }

<span class="pc bpc" id="L101" title="1 of 2 branches missed.">            if (debugLogging) {</span>
<span class="nc" id="L102">                LOG.info(&quot;Removing comments...&quot;);</span>
            }
            // Find the start of the comment
<span class="fc" id="L105">            n = 0;</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            while ((n = sb.indexOf(&quot;/*&quot;, n)) != -1) {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                if (sb.charAt(n + 2) == '*') { // Retain special comments</span>
<span class="nc" id="L108">                    n += 2;</span>
<span class="nc" id="L109">                    continue;</span>
                }
<span class="nc" id="L111">                k = sb.indexOf(&quot;*/&quot;, n + 2);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                if (k == -1) {</span>
<span class="nc" id="L113">                    throw new UnterminatedCommentException();</span>
                }
<span class="nc" id="L115">                sb.delete(n, k + 2);</span>
            }
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            if (debugLogging) {</span>
<span class="nc" id="L118">                LOG.info(sb.toString());</span>
<span class="nc" id="L119">                LOG.info(&quot;\n\n&quot;);</span>
            }

<span class="pc bpc" id="L122" title="1 of 2 branches missed.">            if (debugLogging) {</span>
<span class="nc" id="L123">                LOG.info(&quot;Parsing and processing selectors...&quot;);</span>
            }
<span class="fc" id="L125">            Vector&lt;Selector&gt; selectors = new Vector&lt;&gt;();</span>
<span class="fc" id="L126">            n = 0;</span>
<span class="fc" id="L127">            j = 0;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            for (int i = 0; i &lt; sb.length(); i++) {</span>
<span class="fc" id="L129">                curr = sb.charAt(i);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                if (j &lt; 0) {</span>
<span class="nc" id="L131">                    throw new UnbalancedBracesException();</span>
                }
<span class="fc bfc" id="L133" title="All 2 branches covered.">                if (curr == '{') {</span>
<span class="fc" id="L134">                    j++;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">                } else if (curr == '}') {</span>
<span class="fc" id="L136">                    j--;</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">                    if (j == 0) {</span>
                        try {
<span class="fc" id="L139">                            selectors.addElement(new Selector(sb.substring(n, i + 1)));</span>
<span class="nc" id="L140">                        } catch (UnterminatedSelectorException usex) {</span>
<span class="nc" id="L141">                            LOG.warning(&quot;Unterminated selector: &quot; + usex.getMessage());</span>
<span class="nc" id="L142">                        } catch (EmptySelectorBodyException ebex) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                            if (debugLogging) {</span>
<span class="nc" id="L144">                                LOG.warning(&quot;Empty selector body: &quot; + ebex.getMessage());</span>
                            }
<span class="pc" id="L146">                        }</span>
<span class="fc" id="L147">                        n = i + 1;</span>
                    }
                }
            }

<span class="fc" id="L152">            StringBuilder result = new StringBuilder();</span>

<span class="fc bfc" id="L154" title="All 2 branches covered.">            for (Selector selector : selectors) {</span>
<span class="fc" id="L155">                result.append(selector);</span>
<span class="fc" id="L156">            }</span>

<span class="pc bpc" id="L158" title="1 of 2 branches missed.">            if (debugLogging) {</span>
<span class="nc" id="L159">                LOG.info(&quot;Process completed successfully.&quot;);</span>
            }

<span class="fc" id="L162">            return result.toString();</span>

<span class="nc" id="L164">        } catch (UnterminatedCommentException ucex) {</span>
<span class="nc" id="L165">            LOG.warning(&quot;Unterminated comment.&quot;);</span>
<span class="nc" id="L166">        } catch (UnbalancedBracesException ubex) {</span>
<span class="nc" id="L167">            LOG.warning(&quot;Unbalanced braces.&quot;);</span>
<span class="nc" id="L168">        } catch (Exception ex) {</span>
<span class="nc" id="L169">            LOG.warning(ex.getMessage());</span>
<span class="nc" id="L170">        }</span>

<span class="nc" id="L172">        return null;</span>

    }
}

class Selector {

<span class="fc" id="L179">    private static final Logger LOG = Logger.getLogger(Selector.class.getName());</span>

<span class="fc" id="L181">    private Property[] properties = null;</span>
<span class="fc" id="L182">    private Vector&lt;Selector&gt; subSelectors = null;</span>
    private String selector;

    /**
     * Creates a new Selector using the supplied strings.
     *
     * @param selector The selector; for example, &quot;div { border: solid 1px red; color: blue; }&quot;
     * @throws IncompleteSelectorException, UnterminatedSelectorException, EmptySelectorBodyException If the selector is incomplete and cannot be parsed.
     */
<span class="fc" id="L191">    Selector(String selector) throws IncompleteSelectorException, UnterminatedSelectorException, EmptySelectorBodyException {</span>
<span class="fc" id="L192">        String[] parts = selector.split(&quot;\\{&quot;); // We have to escape the { with a \ for the regex, which itself requires escaping for the string. Sigh.</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (parts.length &lt; 2) {</span>
<span class="nc" id="L194">            throw new IncompleteSelectorException(selector);</span>
        }

<span class="fc" id="L197">        this.selector = parts[0].trim();</span>

        // Simplify combinators
<span class="fc" id="L200">        this.selector = this.selector.replaceAll(&quot;\\s?(\\+|~|,|=|~=|\\^=|\\$=|\\*=|\\|=|&gt;)\\s?&quot;, &quot;$1&quot;);</span>

        // We're dealing with a nested property, eg @-webkit-keyframes
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (parts.length &gt; 2) {</span>
<span class="nc" id="L204">            this.subSelectors = new Vector&lt;&gt;();</span>
<span class="nc" id="L205">            parts = selector.split(&quot;(\\s*\\{\\s*)|(\\s*\\}\\s*)&quot;);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            for (int i = 1; i &lt; parts.length; i += 2) {</span>
<span class="nc" id="L207">                parts[i] = parts[i].trim();</span>
<span class="nc" id="L208">                parts[i + 1] = parts[i + 1].trim();</span>
<span class="nc bnc" id="L209" title="All 4 branches missed.">                if (!(parts[i].equals(&quot;&quot;) || (parts[i + 1].equals(&quot;&quot;)))) {</span>
<span class="nc" id="L210">                    this.subSelectors.addElement(new Selector(parts[i] + &quot;{&quot; + parts[i + 1] + &quot;}&quot;));</span>
                }
            }
        } else {
<span class="fc" id="L214">            String contents = parts[parts.length - 1].trim();</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            if (CSSMin.debugLogging) {</span>
<span class="nc" id="L216">                LOG.info(&quot;Parsing selector: &quot; + this.selector);</span>
<span class="nc" id="L217">                LOG.info(&quot;\t&quot; + contents);</span>
            }
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">            if (contents.charAt(contents.length() - 1) != '}') { // Ensure that we have a leading and trailing brace.</span>
<span class="nc" id="L220">                throw new UnterminatedSelectorException(selector);</span>
            }
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (contents.length() == 1) {</span>
<span class="nc" id="L223">                throw new EmptySelectorBodyException(selector);</span>
            }
<span class="fc bfc" id="L225" title="All 2 branches covered.">            int endIndex = contents.endsWith(&quot;;}&quot;) ? 2 : 1;</span>
<span class="fc" id="L226">            contents = contents.substring(0, contents.length() - endIndex);</span>

<span class="fc" id="L228">            this.properties = new Property[0];</span>
<span class="fc" id="L229">            this.properties = parseProperties(contents).toArray(this.properties);</span>
<span class="fc" id="L230">            sortProperties(this.properties);</span>
        }
<span class="fc" id="L232">    }</span>

    /**
     * Prints out this selector and its contents nicely, with the contents sorted alphabetically.
     *
     * @return A string representing this selector, minified.
     */
    public String toString() {
<span class="fc" id="L240">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L241">        sb.append(this.selector).append(&quot;{&quot;);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (this.subSelectors != null) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            for (Selector s : this.subSelectors) {</span>
<span class="nc" id="L244">                sb.append(s.toString());</span>
<span class="nc" id="L245">            }</span>
        }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (this.properties != null) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            for (Property p : this.properties) {</span>
<span class="fc" id="L249">                sb.append(p.toString());</span>
            }
        }
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (sb.charAt(sb.length() - 1) == ';') {</span>
<span class="fc" id="L253">            sb.deleteCharAt(sb.length() - 1);</span>
        }
<span class="fc" id="L255">        sb.append(&quot;}&quot;);</span>
<span class="fc" id="L256">        return sb.toString();</span>
    }

    /**
     * Parses out the properties of a selector's body.
     *
     * @param contents The body; for example, &quot;border: solid 1px red; color: blue;&quot;
     * @return An array of properties parsed from this selector.
     */
    private ArrayList&lt;Property&gt; parseProperties(String contents) {
<span class="fc" id="L266">        ArrayList&lt;String&gt; parts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L267">        boolean bInsideString = false,</span>
<span class="fc" id="L268">            bInsideURL = false;</span>
<span class="fc" id="L269">        int j = 0;</span>
        String substr;
<span class="fc bfc" id="L271" title="All 2 branches covered.">        for (int i = 0; i &lt; contents.length(); i++) {</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">            if (bInsideString) { // If we're inside a string</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                bInsideString = !(contents.charAt(i) == '&quot;');</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            } else if (bInsideURL) { // If we're inside a URL</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                bInsideURL = !(contents.charAt(i) == ')');</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            } else if (contents.charAt(i) == '&quot;') {</span>
<span class="nc" id="L277">                bInsideString = true;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            } else if (contents.charAt(i) == '(') {</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">                if ((i - 3) &gt; 0 &amp;&amp; &quot;url&quot;.equals(contents.substring(i - 3, i))) {</span>
<span class="nc" id="L280">                    bInsideURL = true;</span>
                }
<span class="fc bfc" id="L282" title="All 2 branches covered.">            } else if (contents.charAt(i) == ';') {</span>
<span class="fc" id="L283">                substr = contents.substring(j, i);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                if (!(substr.trim().equals(&quot;&quot;))) {</span>
<span class="fc" id="L285">                    parts.add(substr);</span>
                }
<span class="fc" id="L287">                j = i + 1;</span>
            }
        }
<span class="fc" id="L290">        substr = contents.substring(j, contents.length());</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (!(substr.trim().equals(&quot;&quot;))) {</span>
<span class="fc" id="L292">            parts.add(substr);</span>
        }

<span class="fc" id="L295">        ArrayList&lt;Property&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        for (String part : parts) {</span>
            try {
<span class="fc" id="L298">                results.add(new Property(part));</span>
<span class="nc" id="L299">            } catch (IncompletePropertyException ipex) {</span>
<span class="nc" id="L300">                LOG.warning(&quot;Incomplete property in selector \&quot;&quot; + this.selector + &quot;\&quot;: \&quot;&quot; + ipex.getMessage() + &quot;\&quot;&quot;);</span>
<span class="fc" id="L301">            }</span>
<span class="fc" id="L302">        }</span>

<span class="fc" id="L304">        return results;</span>
    }

    /**
     * Sorts the properties array to enhance gzipping.
     *
     * @param properties The array to be sorted.
     */
    private void sortProperties(Property[] properties) {
<span class="fc" id="L313">        Arrays.sort(properties);</span>
<span class="fc" id="L314">    }</span>
}

class Property implements Comparable&lt;Property&gt; {

<span class="fc" id="L319">    private static final Logger LOG = Logger.getLogger(Property.class.getName());</span>

    private String property;
    private Part[] parts;

    /**
     * Creates a new Property using the supplied strings. Parses out the values of the property selector.
     *
     * @param property The property; for example, &quot;border: solid 1px red;&quot; or &quot;-moz-box-shadow: 3px 3px 3px rgba(255, 255, 0, 0.5);&quot;.
     * @throws IncompletePropertyException If the property is incomplete and cannot be parsed.
     */
<span class="fc" id="L330">    Property(String property) throws IncompletePropertyException {</span>
        try {
            // Parse the property.
<span class="fc" id="L333">            ArrayList&lt;String&gt; parts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L334">            boolean bCanSplit = true;</span>
<span class="fc" id="L335">            int j = 0;</span>
            String substr;
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            if (CSSMin.debugLogging) {</span>
<span class="nc" id="L338">                LOG.info(&quot;\t\tExamining property: &quot; + property);</span>
            }
<span class="fc bfc" id="L340" title="All 2 branches covered.">            for (int i = 0; i &lt; property.length(); i++) {</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                if (!bCanSplit) { // If we're inside a string</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                    bCanSplit = (property.charAt(i) == '&quot;');</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                } else if (property.charAt(i) == '&quot;') {</span>
<span class="nc" id="L344">                    bCanSplit = false;</span>
<span class="pc bpc" id="L345" title="1 of 4 branches missed.">                } else if (property.charAt(i) == ':' &amp;&amp; parts.isEmpty()) {</span>
<span class="fc" id="L346">                    substr = property.substring(j, i);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                    if (!(substr.trim().equals(&quot;&quot;))) {</span>
<span class="fc" id="L348">                        parts.add(substr);</span>
                    }
<span class="fc" id="L350">                    j = i + 1;</span>
                }
            }
<span class="fc" id="L353">            substr = property.substring(j, property.length());</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            if (!(substr.trim().equals(&quot;&quot;))) {</span>
<span class="fc" id="L355">                parts.add(substr);</span>
            }
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (parts.size() &lt; 2) {</span>
<span class="nc" id="L358">                throw new IncompletePropertyException(property);</span>
            }

<span class="fc" id="L361">            String prop = parts.get(0).trim();</span>
<span class="pc bpc" id="L362" title="2 of 4 branches missed.">            if (!(prop.length() &gt; 2 &amp;&amp; prop.substring(0, 2).equals(&quot;--&quot;))) {</span>
<span class="fc" id="L363">                prop = prop.toLowerCase();</span>
            }
<span class="fc" id="L365">            this.property = prop;</span>

<span class="fc" id="L367">            this.parts = parseValues(simplifyColours(parts.get(1).trim().replaceAll(&quot;, &quot;, &quot;,&quot;)));</span>

<span class="nc" id="L369">        } catch (PatternSyntaxException e) {</span>
            // Invalid regular expression used.
<span class="fc" id="L371">        }</span>
<span class="fc" id="L372">    }</span>

    /**
     * Prints out this property nicely.
     *
     * @return A string representing this property, minified.
     */
    public String toString() {
<span class="fc" id="L380">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L381">        sb.append(this.property).append(&quot;:&quot;);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        for (Part p : this.parts) {</span>
<span class="fc" id="L383">            sb.append(p.toString()).append(&quot;,&quot;);</span>
        }
<span class="fc" id="L385">        sb.deleteCharAt(sb.length() - 1); // Delete the trailing comma.</span>
<span class="fc" id="L386">        sb.append(&quot;;&quot;);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (CSSMin.debugLogging) {</span>
<span class="nc" id="L388">            LOG.info(sb.toString());</span>
        }
<span class="fc" id="L390">        return sb.toString();</span>
    }

    /**
     * Compare this property with another.
     */
    public int compareTo(Property other) {
        // We can't just use String.compareTo(), because we need to sort properties that have hack prefixes last -- eg, *display should come after display.
<span class="fc" id="L398">        return sort(this.property).compareTo(sort(other.property));</span>
    }

    private String sort(String thisProp) {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (thisProp.charAt(0) == '-') {</span>
<span class="nc" id="L403">            thisProp = thisProp.substring(1);</span>
<span class="nc" id="L404">            thisProp = thisProp.substring(thisProp.indexOf('-') + 1);</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        } else if (thisProp.charAt(0) &lt; 65) {</span>
<span class="nc" id="L406">            thisProp = thisProp.substring(1);</span>
        }
<span class="fc" id="L408">        return thisProp;</span>
    }

    /**
     * Parse the values out of a property.
     *
     * @param contents The property to parse
     * @return An array of Parts
     */
    private Part[] parseValues(String contents) {
<span class="fc" id="L418">        String[] parts = contents.split(&quot;,&quot;);</span>
<span class="fc" id="L419">        Part[] results = new Part[parts.length];</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (int i = 0; i &lt; parts.length; i++) {</span>
            try {
<span class="fc" id="L423">                results[i] = new Part(parts[i], property);</span>
<span class="nc" id="L424">            } catch (Exception e) {</span>
<span class="nc" id="L425">                LOG.warning(e.getMessage());</span>
<span class="nc" id="L426">                results[i] = null;</span>
<span class="fc" id="L427">            }</span>
        }

<span class="fc" id="L430">        return results;</span>
    }

    private String simplifyColours(String contents) {
        // This replacement, although it results in a smaller uncompressed file,
        // actually makes the gzipped file bigger -- people tend to use rgba(0,0,0,0.x)
        // quite a lot, which means that rgba(0,0,0,0) has its first eight or so characters
        // compressed really efficiently; much more so than &quot;transparent&quot;.
        //contents = contents.replaceAll(&quot;rgba\\(0,0,0,0\\)&quot;, &quot;transparent&quot;);

<span class="fc" id="L440">        return simplifyRGBColours(contents);</span>
    }

    // Convert rgb(51,102,153) to #336699 (this code largely based on YUI code)
    private String simplifyRGBColours(String contents) {
<span class="fc" id="L445">        StringBuffer newContents = new StringBuffer();</span>
        StringBuffer hexColour;
        String[] rgbColours;
        int colourValue;

<span class="fc" id="L450">        Pattern pattern = Pattern.compile(&quot;rgb\\s*\\(\\s*([0-9,\\s]+)\\s*\\)&quot;);</span>
<span class="fc" id="L451">        Matcher matcher = pattern.matcher(contents);</span>

<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        while (matcher.find()) {</span>
<span class="nc" id="L454">            hexColour = new StringBuffer(&quot;#&quot;);</span>
<span class="nc" id="L455">            rgbColours = matcher.group(1).split(&quot;,&quot;);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            for (String rgbColour : rgbColours) {</span>
<span class="nc" id="L457">                colourValue = Integer.parseInt(rgbColour);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (colourValue &lt; 16) {</span>
<span class="nc" id="L459">                    hexColour.append(&quot;0&quot;);</span>
                }
<span class="nc" id="L461">                hexColour.append(Integer.toHexString(colourValue));</span>
            }
<span class="nc" id="L463">            matcher.appendReplacement(newContents, hexColour.toString());</span>
        }
<span class="fc" id="L465">        matcher.appendTail(newContents);</span>

<span class="fc" id="L467">        return newContents.toString();</span>
    }
}

class Part {
    private String contents;
    private String property;

    /**
     * Create a new property by parsing the given string.
     *
     * @param contents The string to parse.
     * @throws Exception If the part cannot be parsed.
     */
<span class="fc" id="L481">    Part(String contents, String property) throws Exception {</span>
        // Many of these regular expressions are adapted from those used in the YUI CSS Compressor.

        // For simpler regexes.
<span class="fc" id="L485">        this.contents = &quot; &quot; + contents;</span>
<span class="fc" id="L486">        this.property = property;</span>

<span class="fc" id="L488">        simplify();</span>
<span class="fc" id="L489">    }</span>

    private void simplify() {

        // !important doesn't need to be spaced
<span class="fc" id="L494">        this.contents = this.contents.replaceAll(&quot; !important&quot;, &quot;!important&quot;);</span>

        // Replace 0in, 0cm, etc. with just 0
<span class="fc" id="L497">        this.contents = this.contents.replaceAll(&quot;(\\s)(0)(px|em|%|in|cm|mm|pc|pt|ex)&quot;, &quot;$1$2&quot;);</span>

<span class="fc" id="L499">        this.contents = this.contents.trim();</span>

        // Simplify multiple zeroes
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">        if (this.contents.equals(&quot;0 0 0 0&quot;)) {</span>
<span class="nc" id="L503">            this.contents = &quot;0&quot;;</span>
        }
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">        if (this.contents.equals(&quot;0 0 0&quot;)) {</span>
<span class="nc" id="L506">            this.contents = &quot;0&quot;;</span>
        }
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (this.contents.equals(&quot;0 0&quot;)) {</span>
<span class="nc" id="L509">            this.contents = &quot;0&quot;;</span>
        }

        // Simplify multiple-parameter properties
<span class="fc" id="L513">        simplifyParameters();</span>

        // Simplify font weights
<span class="fc" id="L516">        simplifyFontWeights();</span>

        // Strip unnecessary quotes from url() and single-word parts, and make as much lowercase as possible.
<span class="fc" id="L519">        simplifyQuotesAndCaps();</span>

        // Simplify colours
<span class="fc" id="L522">        simplifyColourNames();</span>
<span class="fc" id="L523">        simplifyHexColours();</span>
<span class="fc" id="L524">    }</span>

    private void simplifyParameters() {
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">        if (this.property.equals(&quot;background-size&quot;)) {</span>
<span class="nc" id="L528">            return;</span>
        }

<span class="fc" id="L531">        StringBuilder newContents = new StringBuilder();</span>

<span class="fc" id="L533">        String[] params = this.contents.split(&quot; &quot;);</span>
<span class="pc bpc" id="L534" title="3 of 4 branches missed.">        if (params.length == 4 &amp;&amp; params[1].equalsIgnoreCase(params[3])) {</span>
            // We can drop off the fourth item if the second and fourth items match
            // ie turn 3px 0 3px 0 into 3px 0 3px
<span class="nc" id="L537">            params = Arrays.copyOf(params, 3);</span>
        }
<span class="pc bpc" id="L539" title="3 of 4 branches missed.">        if (params.length == 3 &amp;&amp; params[0].equalsIgnoreCase(params[2])) {</span>
            // We can drop off the third item if the first and third items match
            // ie turn 3px 0 3px into 3px 0
<span class="nc" id="L542">            params = Arrays.copyOf(params, 2);</span>
        }
<span class="pc bpc" id="L544" title="3 of 4 branches missed.">        if (params.length == 2 &amp;&amp; params[0].equalsIgnoreCase(params[1])) {</span>
            // We can drop off the second item if the first and second items match
            // ie turn 3px 3px into 3px
<span class="nc" id="L547">            params = Arrays.copyOf(params, 1);</span>
        }

<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (String param : params) {</span>
<span class="fc" id="L551">            newContents.append(param).append(&quot; &quot;);</span>
        }
<span class="fc" id="L553">        newContents.deleteCharAt(newContents.length() - 1); // Delete the trailing space</span>

<span class="fc" id="L555">        this.contents = newContents.toString();</span>
<span class="fc" id="L556">    }</span>

    private void simplifyFontWeights() {
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (!this.property.equals(&quot;font-weight&quot;)) {</span>
<span class="fc" id="L560">            return;</span>
        }

<span class="nc" id="L563">        String lcContents = this.contents.toLowerCase();</span>

<span class="nc bnc" id="L565" title="All 2 branches missed.">        for (int i = 0; i &lt; Constants.fontWeightNames.length; i++) {</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">            if (lcContents.equals(Constants.fontWeightNames[i])) {</span>
<span class="nc" id="L567">                this.contents = Constants.fontWeightValues[i];</span>
<span class="nc" id="L568">                break;</span>
            }
        }
<span class="nc" id="L571">    }</span>

    private void simplifyQuotesAndCaps() {
        // Strip quotes from URLs
<span class="pc bpc" id="L575" title="1 of 4 branches missed.">        if ((this.contents.length() &gt; 4) &amp;&amp; (this.contents.substring(0, 4).equalsIgnoreCase(&quot;url(&quot;))) {</span>
<span class="nc" id="L576">            this.contents = this.contents.replaceAll(&quot;(?i)url\\(('|\&quot;)?(.*?)\\1\\)&quot;, &quot;url($2)&quot;);</span>
<span class="pc bpc" id="L577" title="1 of 4 branches missed.">        } else if ((this.contents.length() &gt; 4) &amp;&amp; (this.contents.substring(0, 4).equalsIgnoreCase(&quot;var(&quot;))) {</span>
<span class="nc" id="L578">            this.contents = this.contents.replaceAll(&quot;\\s&quot;, &quot;&quot;);</span>
        } else {
<span class="fc" id="L580">            String[] words = this.contents.split(&quot;\\s&quot;);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">            if (words.length == 1) {</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">                if (!this.property.equalsIgnoreCase(&quot;animation-name&quot;)) {</span>
<span class="fc" id="L583">                    this.contents = this.contents.toLowerCase();</span>
                }
<span class="fc" id="L585">                this.contents = this.contents.replaceAll(&quot;('|\&quot;)?(.*?)\1&quot;, &quot;$2&quot;);</span>
            }
        }
<span class="fc" id="L588">    }</span>

    private void simplifyColourNames() {
<span class="fc" id="L591">        String lcContents = this.contents.toLowerCase();</span>

<span class="fc bfc" id="L593" title="All 2 branches covered.">        for (int i = 0; i &lt; Constants.htmlColourNames.length; i++) {</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">            if (lcContents.equals(Constants.htmlColourNames[i])) {</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                if (Constants.htmlColourValues[i].length() &lt; Constants.htmlColourNames[i].length()) {</span>
<span class="fc" id="L596">                    this.contents = Constants.htmlColourValues[i];</span>
                }
                break;
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">            } else if (lcContents.equals(Constants.htmlColourValues[i])) {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                if (Constants.htmlColourNames[i].length() &lt; Constants.htmlColourValues[i].length()) {</span>
<span class="nc" id="L601">                    this.contents = Constants.htmlColourNames[i];</span>
                }
            }
        }
<span class="fc" id="L605">    }</span>

    private void simplifyHexColours() {
<span class="fc" id="L608">        StringBuffer newContents = new StringBuffer();</span>

<span class="fc" id="L610">        Pattern pattern = Pattern.compile(&quot;#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])&quot;);</span>
<span class="fc" id="L611">        Matcher matcher = pattern.matcher(this.contents);</span>

<span class="fc bfc" id="L613" title="All 2 branches covered.">        while (matcher.find()) {</span>
<span class="pc bpc" id="L614" title="5 of 6 branches missed.">            if (matcher.group(1).equalsIgnoreCase(matcher.group(2)) &amp;&amp; matcher.group(3).equalsIgnoreCase(matcher.group(4)) &amp;&amp; matcher.group(5).equalsIgnoreCase(matcher.group(6))) {</span>
<span class="nc" id="L615">                matcher.appendReplacement(newContents, &quot;#&quot; + matcher.group(1).toLowerCase() + matcher.group(3).toLowerCase() + matcher.group(5).toLowerCase());</span>
            } else {
<span class="fc" id="L617">                matcher.appendReplacement(newContents, matcher.group().toLowerCase());</span>
            }
        }
<span class="fc" id="L620">        matcher.appendTail(newContents);</span>

<span class="fc" id="L622">        this.contents = newContents.toString();</span>
<span class="fc" id="L623">    }</span>

    /**
     * Returns itself.
     *
     * @return this part's string representation.
     */
    public String toString() {
<span class="fc" id="L631">        return this.contents;</span>
    }
}

<span class="nc" id="L635">class UnterminatedCommentException extends Exception {</span>
}

<span class="nc" id="L638">class UnbalancedBracesException extends Exception {</span>
}

class IncompletePropertyException extends Exception {
    private final String message;

<span class="nc" id="L644">    IncompletePropertyException(String message) {</span>
<span class="nc" id="L645">        this.message = message;</span>
<span class="nc" id="L646">    }</span>

    public String getMessage() {
<span class="nc" id="L649">        return this.message;</span>
    }
}

class EmptySelectorBodyException extends Exception {
    private final String message;

<span class="nc" id="L656">    EmptySelectorBodyException(String message) {</span>
<span class="nc" id="L657">        this.message = message;</span>
<span class="nc" id="L658">    }</span>

    public String getMessage() {
<span class="nc" id="L661">        return this.message;</span>
    }
}

class UnterminatedSelectorException extends Exception {
    private final String message;

<span class="nc" id="L668">    UnterminatedSelectorException(String message) {</span>
<span class="nc" id="L669">        this.message = message;</span>
<span class="nc" id="L670">    }</span>

    public String getMessage() {
<span class="nc" id="L673">        return this.message;</span>
    }
}

class IncompleteSelectorException extends Exception {
    private final String message;

<span class="nc" id="L680">    IncompleteSelectorException(String message) {</span>
<span class="nc" id="L681">        this.message = message;</span>
<span class="nc" id="L682">    }</span>

    public String getMessage() {
<span class="nc" id="L685">        return this.message;</span>
    }
}

<span class="nc" id="L689">class Constants {</span>
<span class="fc" id="L690">    static final String[] htmlColourNames = {&quot;aliceblue&quot;, &quot;antiquewhite&quot;, &quot;aqua&quot;, &quot;aquamarine&quot;, &quot;azure&quot;, &quot;beige&quot;, &quot;bisque&quot;, &quot;black&quot;, &quot;blanchedalmond&quot;, &quot;blue&quot;, &quot;blueviolet&quot;, &quot;brown&quot;, &quot;burlywood&quot;, &quot;cadetblue&quot;, &quot;chartreuse&quot;, &quot;chocolate&quot;, &quot;coral&quot;, &quot;cornflowerblue&quot;, &quot;cornsilk&quot;, &quot;crimson&quot;, &quot;cyan&quot;, &quot;darkblue&quot;, &quot;darkcyan&quot;, &quot;darkgoldenrod&quot;, &quot;darkgray&quot;, &quot;darkgreen&quot;, &quot;darkkhaki&quot;, &quot;darkmagenta&quot;, &quot;darkolivegreen&quot;, &quot;darkorange&quot;, &quot;darkorchid&quot;, &quot;darkred&quot;, &quot;darksalmon&quot;, &quot;darkseagreen&quot;, &quot;darkslateblue&quot;, &quot;darkslategray&quot;, &quot;darkturquoise&quot;, &quot;darkviolet&quot;, &quot;deeppink&quot;, &quot;deepskyblue&quot;, &quot;dimgray&quot;, &quot;dodgerblue&quot;, &quot;firebrick&quot;, &quot;floralwhite&quot;, &quot;forestgreen&quot;, &quot;fuchsia&quot;, &quot;gainsboro&quot;, &quot;ghostwhite&quot;, &quot;gold&quot;, &quot;goldenrod&quot;, &quot;gray&quot;, &quot;green&quot;, &quot;greenyellow&quot;, &quot;honeydew&quot;, &quot;hotpink&quot;, &quot;indianred &quot;, &quot;indigo &quot;, &quot;ivory&quot;, &quot;khaki&quot;, &quot;lavender&quot;, &quot;lavenderblush&quot;, &quot;lawngreen&quot;, &quot;lemonchiffon&quot;, &quot;lightblue&quot;, &quot;lightcoral&quot;, &quot;lightcyan&quot;, &quot;lightgoldenrodyellow&quot;, &quot;lightgrey&quot;, &quot;lightgreen&quot;, &quot;lightpink&quot;, &quot;lightsalmon&quot;, &quot;lightseagreen&quot;, &quot;lightskyblue&quot;, &quot;lightslategray&quot;, &quot;lightsteelblue&quot;, &quot;lightyellow&quot;, &quot;lime&quot;, &quot;limegreen&quot;, &quot;linen&quot;, &quot;magenta&quot;, &quot;maroon&quot;, &quot;mediumaquamarine&quot;, &quot;mediumblue&quot;, &quot;mediumorchid&quot;, &quot;mediumpurple&quot;, &quot;mediumseagreen&quot;, &quot;mediumslateblue&quot;, &quot;mediumspringgreen&quot;, &quot;mediumturquoise&quot;, &quot;mediumvioletred&quot;, &quot;midnightblue&quot;, &quot;mintcream&quot;, &quot;mistyrose&quot;, &quot;moccasin&quot;, &quot;navajowhite&quot;, &quot;navy&quot;, &quot;oldlace&quot;, &quot;olive&quot;, &quot;olivedrab&quot;, &quot;orange&quot;, &quot;orangered&quot;, &quot;orchid&quot;, &quot;palegoldenrod&quot;, &quot;palegreen&quot;, &quot;paleturquoise&quot;, &quot;palevioletred&quot;, &quot;papayawhip&quot;, &quot;peachpuff&quot;, &quot;peru&quot;, &quot;pink&quot;, &quot;plum&quot;, &quot;powderblue&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;rosybrown&quot;, &quot;royalblue&quot;, &quot;saddlebrown&quot;, &quot;salmon&quot;, &quot;sandybrown&quot;, &quot;seagreen&quot;, &quot;seashell&quot;, &quot;sienna&quot;, &quot;silver&quot;, &quot;skyblue&quot;, &quot;slateblue&quot;, &quot;slategray&quot;, &quot;snow&quot;, &quot;springgreen&quot;, &quot;steelblue&quot;, &quot;tan&quot;, &quot;teal&quot;, &quot;thistle&quot;, &quot;tomato&quot;, &quot;turquoise&quot;, &quot;violet&quot;, &quot;wheat&quot;, &quot;white&quot;, &quot;whitesmoke&quot;, &quot;yellow&quot;, &quot;yellowgreen&quot;};</span>
<span class="fc" id="L691">    static final String[] htmlColourValues = {&quot;#f0f8ff&quot;, &quot;#faebd7&quot;, &quot;#00ffff&quot;, &quot;#7fffd4&quot;, &quot;#f0ffff&quot;, &quot;#f5f5dc&quot;, &quot;#ffe4c4&quot;, &quot;#000&quot;, &quot;#ffebcd&quot;, &quot;#00f&quot;, &quot;#8a2be2&quot;, &quot;#a52a2a&quot;, &quot;#deb887&quot;, &quot;#5f9ea0&quot;, &quot;#7fff00&quot;, &quot;#d2691e&quot;, &quot;#ff7f50&quot;, &quot;#6495ed&quot;, &quot;#fff8dc&quot;, &quot;#dc143c&quot;, &quot;#0ff&quot;, &quot;#00008b&quot;, &quot;#008b8b&quot;, &quot;#b8860b&quot;, &quot;#a9a9a9&quot;, &quot;#006400&quot;, &quot;#bdb76b&quot;, &quot;#8b008b&quot;, &quot;#556b2f&quot;, &quot;#ff8c00&quot;, &quot;#9932cc&quot;, &quot;#8b0000&quot;, &quot;#e9967a&quot;, &quot;#8fbc8f&quot;, &quot;#483d8b&quot;, &quot;#2f4f4f&quot;, &quot;#00ced1&quot;, &quot;#9400d3&quot;, &quot;#ff1493&quot;, &quot;#00bfff&quot;, &quot;#696969&quot;, &quot;#1e90ff&quot;, &quot;#b22222&quot;, &quot;#fffaf0&quot;, &quot;#228b22&quot;, &quot;#f0f&quot;, &quot;#dcdcdc&quot;, &quot;#f8f8ff&quot;, &quot;#ffd700&quot;, &quot;#daa520&quot;, &quot;#808080&quot;, &quot;#008000&quot;, &quot;#adff2f&quot;, &quot;#f0fff0&quot;, &quot;#ff69b4&quot;, &quot;#cd5c5c&quot;, &quot;#4b0082&quot;, &quot;#fffff0&quot;, &quot;#f0e68c&quot;, &quot;#e6e6fa&quot;, &quot;#fff0f5&quot;, &quot;#7cfc00&quot;, &quot;#fffacd&quot;, &quot;#add8e6&quot;, &quot;#f08080&quot;, &quot;#e0ffff&quot;, &quot;#fafad2&quot;, &quot;#d3d3d3&quot;, &quot;#90ee90&quot;, &quot;#ffb6c1&quot;, &quot;#ffa07a&quot;, &quot;#20b2aa&quot;, &quot;#87cefa&quot;, &quot;#789&quot;, &quot;#b0c4de&quot;, &quot;#ffffe0&quot;, &quot;#0f0&quot;, &quot;#32cd32&quot;, &quot;#faf0e6&quot;, &quot;#f0f&quot;, &quot;#800000&quot;, &quot;#66cdaa&quot;, &quot;#0000cd&quot;, &quot;#ba55d3&quot;, &quot;#9370d8&quot;, &quot;#3cb371&quot;, &quot;#7b68ee&quot;, &quot;#00fa9a&quot;, &quot;#48d1cc&quot;, &quot;#c71585&quot;, &quot;#191970&quot;, &quot;#f5fffa&quot;, &quot;#ffe4e1&quot;, &quot;#ffe4b5&quot;, &quot;#ffdead&quot;, &quot;#000080&quot;, &quot;#fdf5e6&quot;, &quot;#808000&quot;, &quot;#6b8e23&quot;, &quot;#ffa500&quot;, &quot;#ff4500&quot;, &quot;#da70d6&quot;, &quot;#eee8aa&quot;, &quot;#98fb98&quot;, &quot;#afeeee&quot;, &quot;#d87093&quot;, &quot;#ffefd5&quot;, &quot;#ffdab9&quot;, &quot;#cd853f&quot;, &quot;#ffc0cb&quot;, &quot;#dda0dd&quot;, &quot;#b0e0e6&quot;, &quot;#800080&quot;, &quot;#f00&quot;, &quot;#bc8f8f&quot;, &quot;#4169e1&quot;, &quot;#8b4513&quot;, &quot;#fa8072&quot;, &quot;#f4a460&quot;, &quot;#2e8b57&quot;, &quot;#fff5ee&quot;, &quot;#a0522d&quot;, &quot;#c0c0c0&quot;, &quot;#87ceeb&quot;, &quot;#6a5acd&quot;, &quot;#708090&quot;, &quot;#fffafa&quot;, &quot;#00ff7f&quot;, &quot;#4682b4&quot;, &quot;#d2b48c&quot;, &quot;#008080&quot;, &quot;#d8bfd8&quot;, &quot;#ff6347&quot;, &quot;#40e0d0&quot;, &quot;#ee82ee&quot;, &quot;#f5deb3&quot;, &quot;#fff&quot;, &quot;#f5f5f5&quot;, &quot;#ff0&quot;, &quot;#9acd32&quot;};</span>
<span class="fc" id="L692">    static final String[] fontWeightNames = {&quot;normal&quot;, &quot;bold&quot;, &quot;bolder&quot;, &quot;lighter&quot;};</span>
<span class="fc" id="L693">    static final String[] fontWeightValues = {&quot;400&quot;, &quot;700&quot;, &quot;900&quot;, &quot;100&quot;};</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>